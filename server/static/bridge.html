<html>
  <head>
    <title>party-line single file hack</title>
    <meta charset="UTF-8" />
    <script src="https://unpkg.com/@daily-co/daily-js"></script>
  </head>

  <body onload="main()">
    <!-- the good stuff -->

    <script>
      // ---- mutable globals ----

      let call, oldConsole, oldOnError;
      let audioElementsBySessionId = {};

      function main() {
        swizzleConsole();
        swizzleOnError();
      }

      function swizzleConsole() {
        if (oldConsole != undefined) {
          return;
        }

        oldConsole = window.console;

        window.console = (function (oldConsole) {
          function redirect(lvl) {
            return function (msg) {
              postNativeConsoleMessage(lvl, msg);
              oldConsole[lvl](msg);
            };
          }
          return {
            ...oldConsole,
            log: redirect("log"),
            info: redirect("info"),
            warn: redirect("warn"),
            error: redirect("error"),
          };
        })(window.console);
      }

      function swizzleOnError() {
        if (oldOnError != undefined) {
          return;
        }

        oldOnError = window.onerror;

        window.onerror = (function (msg, url, line, column, error) {
          return function (msg) {
            postNativeErrorMessage(msg, url, line, column, error);
            oldOnError(msg, url, line, column, error);
          };
        })(window.onerror);
      }

      // ---- room and token creation ----

      function createRoomNonBlocking({}) {
        setTimeout(function () {
          createRoomAsync({});
        }, 0);
      }

      async function createRoomAsync({}) {
        console.log("[CREATING ROOM]");

        let res = await fetch(
          "https://audio-only-server.netlify.app/.netlify/functions/room",
          {
            method: "POST",
          }
        );
        let room = await res.json();

        console.log("[CREATED ROOM]", room);

        postNativeEventMessage({
          action: "demo-created-room",
          room: room,
        });

        return room;
      }

      function createTokenNonBlocking({ roomName }) {
        setTimeout(function () {
          createTokenAsync({ roomName });
        }, 0);
      }

      async function createTokenAsync({ roomName }) {
        console.log("[CREATING TOKEN]");

        let res = await fetch(
          "https://audio-only-server.netlify.app/.netlify/functions/token",
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              properties: {
                room_name: roomName,
              },
            }),
          }
        );
        let token = await res.json();

        console.log("[CREATED TOKEN]", token);

        postNativeEventMessage({
          action: "demo-created-token",
          token: token,
        });

        return token;
      }

      function createAndJoinRoomNonBlocking({ userName }) {
        setTimeout(function () {
          createAndJoinRoomAsync({ userName });
        }, 0);
      }

      async function createAndJoinRoomAsync({ userName }) {
        console.log("[CREATING & JOINING ROOM]");

        let roomData = await createRoomAsync({});

        let roomUrl = roomData.url;
        let roomName = roomData.name;
        let token = roomData.token;

        await joinRoomAsync({ userName, roomUrl, roomName, token });
      }

      function joinRoomNonBlocking({ userName, roomUrl, token }) {
        setTimeout(function () {
          joinRoomAsync({ userName, roomUrl, token });
        }, 0);
      }

      async function joinRoomAsync({ userName, roomUrl, token }) {
        console.log("[JOINING ROOM]");

        let tag = LISTENER_TAG;

        if (token != undefined) {
          tag = MODERATOR_TAG;
        }

        token = token ?? "";

        userName = setRoleTagInUserName(userName, tag);

        if (call != undefined) {
          await call.leave();
        } else {
          call = DailyIframe.createCallObject({
            userName: userName,
            audioSource: true, // start with audio on to get mic permission from user at start
            videoSource: false,
            dailyConfig: {
              experimentalChromeVideoMuteLightOff: true,
            },
          });

          window.call = call;

          call.on("joined-meeting", handleJoinedMeeting);

          call.on("error", handleError);

          call.on("participant-joined", handleParticipantJoined);
          call.on("participant-updated", handleParticipantUpdated);
          call.on("participant-left", handleParticipantLeft);
          call.on("app-message", handleAppMessage);

          call.on("active-speaker-change", handleActiveSpeakerChange);

          call.on("track-started", handleTrackStarted);
          call.on("track-stopped", handleTrackStopped);
        }

        await call.join({ url: roomUrl, token });

        call.setUserName(userName);

        // now mute, so everyone joining is muted by default
        call.setLocalAudio(false);

        let room = await call.room();

        postNativeEventMessage({
          action: "demo-joined-room",
          room: room,
        });
      }

      function leaveRoomNonBlocking({}) {
        setTimeout(function () {
          leaveRoomAsync({});
        }, 0);
      }

      async function leaveRoomAsync({}) {
        console.log("[LEAVING ROOM]");
        await call.leave();
      }

      // ---- user controls ----

      function toggleMic() {
        let currentAudio = call.participants().local.audio;
        call.updateParticipant("local", { setAudio: !currentAudio });
      }

      function setLocalAudio(flag) {
        call.setLocalAudio(flag);
      }

      function setHandRaised(handRaised) {
        let participant = call.participants().local;

        let userName = participant.user_name.replace(/^✋ /, "");

        if (handRaised) {
          userName = `✋ ${userName}`;
        }

        setUserName(userName);
      }

      function setUserName(userName) {
        call.setUserName(userName);
      }

      // ---- moderator controls ----

      function muteParticipant(sessionId) {
        call.updateParticipant(sessionId, { setAudio: false });
      }

      function ejectParticipant(sessionId) {
        call.updateParticipant(sessionId, { eject: true });
      }

      function makeModerator(sessionId) {
        setRole(sessionId, MODERATOR_TAG);
      }

      function makeSpeaker(sessionId) {
        setRole(sessionId, SPEAKER_TAG);
      }

      function makeListener(sessionId) {
        setRole(sessionId, LISTENER_TAG);
      }

      function setRole(sessionId, roleTag) {
        let participant = call.participants()[sessionId];

        if (participant == undefined) {
          return;
        }

        let userName = participant.name;
        let id = participant.sessionId;

        let msg;

        switch (roleTag) {
          case MODERATOR_TAG:
            msg = MSG_MAKE_MODERATOR;
            break;
          case SPEAKER_TAG:
            msg = MSG_MAKE_SPEAKER;
            break;
          case LISTENER_TAG:
            msg = MSG_MAKE_LISTENER;
            break;
        }

        call.sendAppMessage({ userName, id, msg }, sessionId);
      }

      // ---- call properties ----

      function participants() {
        let participants = call.participants();
        return JSON.stringify(participants);
      }

      // ---- join event handlers ----

      function handleJoinedMeeting(evt) {
        console.log("[JOINED MEETING]");
        console.log(evt);

        postNativeEventMessage(evt);
      }

      // ---- error event handlers ----

      function handleError(evt) {
        console.log("[ERROR]");
        console.log(evt);

        postNativeEventMessage(evt);
      }

      // ---- participant event handlers ----

      function handleParticipantJoined(evt) {
        console.log("[PARTICIPANT JOINED]");
        console.log(evt);

        postNativeEventMessage(evt);
      }

      function handleParticipantUpdated(evt) {
        console.log("[PARTICIPANT UPDATED]");
        console.log(evt);

        postNativeEventMessage(evt);
      }

      function handleParticipantLeft(evt) {
        console.log("[PARTICIPANT LEFT]");
        console.log(evt);

        postNativeEventMessage(evt);
      }

      function handleActiveSpeakerChange(evt) {
        console.log("[ACTIVE SPEAKER CHANGE]");
        console.log(evt);

        postNativeEventMessage(evt);
      }

      // ---- peer-to-peer message passing ----

      const MODERATOR_TAG = "MOD";
      const SPEAKER_TAG = "SPK";
      const LISTENER_TAG = "LST";

      const MSG_MAKE_MODERATOR = "make-moderator";
      const MSG_MAKE_SPEAKER = "make-speaker";
      const MSG_MAKE_LISTENER = "make-listener";
      // const MSG_FORCE_MUTE = 'force-mute';
      // const MSG_FORCE_EJECT = 'force-eject';

      async function handleAppMessage(evt) {
        console.log("[APP MESSAGE]");
        console.log(evt);

        try {
          switch (evt.data.msg) {
            case MSG_MAKE_MODERATOR:
              await becomeModerator();
              break;
            case MSG_MAKE_SPEAKER:
              becomeSpeaker();
              break;
            case MSG_MAKE_LISTENER:
              becomeListener();
              break;
          }
        } catch (e) {
          console.error(e);
        }

        postNativeEventMessage(evt);
      }

      async function becomeModerator() {
        console.log("[MAKING MODERATOR]");

        let userName = call.participants().local.user_name;
        let roomUrl = call.properties.url;

        let room = await call.room();

        await call.leave();

        let tokenData = await createTokenAsync({ roomName: room.name });
        let token = tokenData.token;

        await joinRoomAsync({ userName, roomUrl, token });
      }

      function becomeSpeaker() {
        console.log("[MAKING SPEAKER]");

        let userName = call.participants().local.user_name;
        userName = setRoleTagInUserName(userName, SPEAKER_TAG);

        call.setUserName(userName);
      }

      function becomeListener() {
        console.log("[MAKING LISTENER]");

        let userName = call.participants().local.user_name;
        userName = setRoleTagInUserName(userName, LISTENER_TAG);

        call.setUserName(userName);
        call.setLocalAudio(false);
      }

      function setRoleTagInUserName(userName, tag) {
        userName = userName.replace(/_(LST|SPK|MOD)$/, "");
        return `${userName}_${tag}`;
      }

      // ---- start and stop audio tracks ----

      function handleTrackStarted(evt) {
        console.log("[TRACK STARTED]");
        console.log(evt);

        // don't play the local audio track (echo!)
        if (evt.participant.local) {
          return;
        }

        startTrack(evt.participant.sessionId, evt.track);

        postNativeEventMessage(evt);
      }

      function handleTrackStopped(evt) {
        console.log("[TRACK STOPPED]");
        console.log(evt);

        stopTrack(evt.participant.sessionId);

        postNativeEventMessage(evt);
      }

      function startTrack(sessionId, track) {
        // sanity check to make sure this is an audio track
        if (!(track && track.kind === "audio")) {
          return;
        }

        let audioElement = document.createElement("audio");

        audioElement.autoplay = true;
        audioElement.setAttribute("playsinline", "");

        audioElement.srcObject = new MediaStream([track]);

        document.body.appendChild(audioElement);

        audioElement.play();

        audioElementsBySessionId[sessionId] = audioElement;
      }

      function stopTrack(sessionId) {
        let audioElement = audioElementsBySessionId[sessionId];

        if (audioElement != undefined) {
          audioElement.remove();
          audioElement = null;
          audioElementsBySessionId.delete(sessionId);
        }
      }

      // ---- native bridge ----

      function postNativeEventMessage(evt) {
        if (window.webkit == undefined) {
          return;
        }
        let messageHandler = window.webkit.messageHandlers.events;
        if (messageHandler == undefined) {
          return;
        }
        messageHandler.postMessage(JSON.stringify(evt));
      }

      function postNativeConsoleMessage(lvl, msg) {
        if (window.webkit == undefined) {
          return;
        }
        let messageHandler = window.webkit.messageHandlers.console;
        if (messageHandler == undefined) {
          return;
        }
        messageHandler.postMessage(
          JSON.stringify({
            level: lvl,
            content: msg,
          })
        );
      }

      function postNativeErrorMessage(msg, url, line, column, error) {
        if (window.webkit == undefined) {
          return;
        }
        let messageHandler = window.webkit.messageHandlers.errors;
        if (messageHandler == undefined) {
          return;
        }
        messageHandler.postMessage(
          JSON.stringify({
            message: msg,
            url,
            line,
            column,
            error,
          })
        );
      }
    </script>
  </body>
</html>
